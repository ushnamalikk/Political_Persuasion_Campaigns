from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from time import sleep
import undetected_chromedriver as uc
from selenium.webdriver.support.ui import WebDriverWait
from fake_useragent import UserAgent
from selenium.webdriver.support import expected_conditions as EC
import json
import os
import glob

#faceless undetected chrome
op = webdriver.ChromeOptions()
op.add_experimental_option("detach", True)
op.add_experimental_option("excludeSwitches", ["enable-logging"])
BASE_DOWNLOAD_PATH = os.path.join(os.getcwd(), 'downloads')

prefs = {   'download.default_directory': BASE_DOWNLOAD_PATH,
            "download.prompt_for_download": False,
            "download.directory_upgrade": True
        }

op.add_experimental_option('prefs',prefs)

print("Starting the driver")


#driver variables
options = webdriver.ChromeOptions()
options.add_argument("--no-sandbox")
options.add_argument("--disable-dev-shm-usage")
options.add_argument("--disable-gpu")
options.add_argument("--disable-features=NetworkService")
options.add_argument("--window-size=1920x1080")
options.add_argument(f"--user-data-dir=user_data")





driver = uc.Chrome(options=options)
wait = WebDriverWait(driver, 1000)



#XPATHs
textarea = "//textarea[contains(@placeholder,'typing')]"
generate = "//button[contains(@aria-label,'Generate')]"
regenerate = "//button[contains(@aria-label,'Regenerate')]"
download = "//button[contains(@aria-label,'Download')]"




#open website 
print("Driver started")
driver.get('https://elevenlabs.io/app/speech-synthesis/text-to-speech')
sleep(5)

# function to rename the most recent file downloaded
def rename_latest_file(download_folder, new_name):
    # Get the list of files in the download folder
    files = glob.glob(os.path.join(download_folder, '*'))
    # Sort the files by modification time (most recent last)
    files.sort(key=os.path.getmtime, reverse=True)
    
    if files:
        # Get the most recent file
        latest_file = files[0]
        # Create new file name
        new_file_path = os.path.join(download_folder, new_name)
        # Rename the file
        os.rename(latest_file, new_file_path)
        # print(f"Renamed {latest_file} to {new_file_path}")
        
def update_download_path(folder_path):
    # Change the default download directory dynamically during runtime
    params = {'behavior': 'allow', 'downloadPath': folder_path}
    driver.execute_cdp_cmd('Page.setDownloadBehavior', params)

# function that will generate the audio
def generate_audio(content):
    # select the textarea, clear it and enter the content
    driver.find_element(By.XPATH, textarea).clear()
    driver.find_element(By.XPATH, textarea).send_keys(content)

    # click on the generate button
    driver.find_element(By.XPATH, generate).click()

    # wait for the audio to be generated by until regenerate button is clickable
    wait.until(EC.element_to_be_clickable((By.XPATH, regenerate)))
    sleep(1)
    
    wait.until(EC.element_to_be_clickable((By.XPATH, download))).click()
    
    sleep(5)
    
    





# load dict from json (if present)
try:
    with open('responseDict.json', 'r') as fp:
        responseDict = json.load(fp)
except:
    print("No response dict present in pwd")

# Load checkpoint dict (if present)
checkpoint_file = 'checkpoint.json'
try:
    with open(checkpoint_file, 'r') as cp:
        checkpoint = json.load(cp)
except FileNotFoundError:
    print("No checkpoint file found, starting fresh.")
    checkpoint = {}
    
    
for key in responseDict:
    print(f"Generating audio for {key}")
    
    entire_text = responseDict[key]['second']
    paragraphs = entire_text.split('\n\n')
    
    key_folder = os.path.join(BASE_DOWNLOAD_PATH, key)
    os.makedirs(key_folder,exist_ok=True)
    
    update_download_path(key_folder)
    
    # Initialize checkpoint for this key if not already present
    if key not in checkpoint:
        checkpoint[key] = {"processed_paragraphs": []}

    for i, paragraph in enumerate(paragraphs):
        
        if i in checkpoint[key]["processed_paragraphs"]:
            print(f"Skipping already processed paragraph {i} for key {key}")
            continue
        
        print(f"Generating audio for paragraph {i}")
        
        # print(paragraph)
        generate_audio(paragraph)
        new_file_name = f"paragraph_{i}.mp3"
        rename_latest_file(key_folder, new_file_name)
        # break

        # Add paragraph index to the checkpoint and save
        checkpoint[key]["processed_paragraphs"].append(i)
        with open(checkpoint_file, 'w') as cp:
            json.dump(checkpoint, cp)
            
    print(f"Audio generated for {key}")



print("Audio generated for all paragraphs")

driver.quit()